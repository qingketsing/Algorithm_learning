# P1219八皇后问题
##### 非常经典的dfs算法入门题目！

### 重点：标记，判断，回溯
本题的难点基本上就是这三个点<br>
用几个二位数组来标记能否放置皇后会浪费超级多的空间和时间<br>
看别人的做法，会爆TLE<br>

所以我们来简单分析一下该怎么标记

    -------------------
    -     -     -     -
    -------------------
    -     -  P  -     -
    -------------------
    -     -     -     -
    -------------------
    -     -     -     -
    -------------------

默认横坐标为x,纵坐标为y<br>
P点存在的一行肯定不能再放一个皇后，所以直接从下一行开始判断<br>
同理，竖着的一列肯定也不能存在其余的皇后，所以直接标记x<br>
P点左下到右上的对角线中,x+y为一个常量<br>
所以直接定义一个数组，用来标记左下到右上的斜线<br>
同理，右下到左上的斜线不变量是y-x<br>
### 但是这里需要注意，y-x是会出现负数情况的！！！
所以我们用x-y+n来代替y-x，这样就不会出现负数的情况了<br>
判断完如果可以放，就把这一行的x轴的坐标记录下来<br>
进行下一行判断，如果到达边界值，而且满足条件，那就输出答案，一直到超过三次为止，超过三次之后仍然记录答案的数量，但是不再输出(非常神奇的思路)<br>

    if(x == n+1){
        t++;
        if(t <= 3){
            for(int j = 1;j <= n;j++){
                cout << row[j] << " ";
            }
            cout << endl;
        }
        return 0;
    }

输出完答案后不断的返回，记住这时候要状态回溯！<br>

    c[i] = 0;
    m1[x+i] = 0;
    m2[x-i+n] = 0;

最后，记得在主体函数里输出一下答案的数量

    cout << t << endl;

以下是题解：

    #include <bits/stdc++.h>
    using namespace std;

    int n,c[30],m1[30],m2[30],row[15];
    int t = 0;

    int dfs(int x){
        if(x == n+1){
            t++;
            if(t <= 3){
                for(int j = 1;j <= n;j++){
                    cout << row[j] << " ";
                }
                cout << endl;
            }
            return 0;
        }

        for(int i = 1;i <= n;i++){
            if(c[i] || m1[x+i] || m2[x-i+n]){
                continue;
            }else{
                c[i] = 1;
                m1[x+i] = 1;
                m2[x-i+n] = 1;
                row[x] = i;
            }
            dfs(x+1);
            c[i] = 0;
            m1[x+i] = 0;
            m2[x-i+n] = 0;
        }
        return 0;
    }

    int main(){
        cin >> n;
        dfs(1);
        cout << t << endl;
        return 0;
    }